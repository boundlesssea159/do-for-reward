{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_ccipRouter)) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConverter {\n    // Token/USD * 1e18\n    function getPrice(\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        uint8 decimal = priceFeed.decimals();\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        return uint256(uint256(answer) * 10 ** (18 - decimal));\n    }\n\n    // return TokenAmount(10**18)\n    function getTokenAmountByUSD(\n        uint256 USDAmount, // 10**18\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        uint256 price = getPrice(priceFeed);\n        return (USDAmount * 1e18) / price;\n    }\n\n    // return USD(10**18)\n    function getConversionRate(\n        uint256 tokenAmount, // 10**18\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        return getPrice(priceFeed) * (tokenAmount / 1e18);\n    }\n}\n"
    },
    "contracts/RewardReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {PriceConverter} from \"./PriceConverter.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\ncontract RewardReceiver is CCIPReceiver {\n    using PriceConverter for uint256;\n\n    AggregatorV3Interface private priceFeed;\n\n    event Received(address to, uint256 amount);\n    error ReceivedFailed(address to, uint256 amount);\n\n    constructor(\n        address _router,\n        address _priceFeed\n    ) CCIPReceiver(_router) {\n        priceFeed = AggregatorV3Interface(_priceFeed);\n    }\n\n    function _ccipReceive(\n        Client.Any2EVMMessage memory message\n    ) internal override {\n        (address to, uint256 amount) = abi.decode(\n            message.data,\n            (address, uint256)\n        );\n        // amount is USD * 1e18\n        balanceShouldMoreThanAmount(amount);\n        uint256 tokenAmount = amount.getTokenAmountByUSD(priceFeed);\n        (bool success, ) = to.call{value: tokenAmount}(\"\");\n        if (!success) {\n            revert ReceivedFailed(to, tokenAmount);\n        }\n        emit Received(to, tokenAmount);\n    }\n\n    function balanceShouldMoreThanAmount(uint256 amount) internal view {\n        require(\n            address(this).balance.getConversionRate(priceFeed) >= amount,\n            \"need more balance\"\n        );\n    }\n}\n"
    },
    "contracts/Tasks.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {IERC20} from \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport {PriceConverter} from \"./PriceConverter.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\ncontract Tasks {\n    using PriceConverter for uint256;\n\n    enum Status {\n        Created,\n        Executing,\n        Finished\n    }\n\n    struct task {\n        string name;\n        string description;\n        uint256 deadline;\n        uint256 reward; // USD\n        Status status;\n    }\n\n    struct applierInfomation {\n        address account;\n        uint256 chainId;\n    }\n\n    struct chainContractAndSelector {\n        address contractAddress;\n        uint64 selector;\n    }\n\n    event TaskApplied(uint256 indexed index, address account);\n    event TransferSuccess(address account, uint256 amount);\n    event MessageSent(bytes32 messageId);\n\n    error TaskInvalid();\n    error TaskAlreadyExists(string name);\n    error TaskNotExist(uint256 index);\n    error TaskHasBeenApplied(uint256 index);\n    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees);\n\n    address private owner;\n\n    task[] private tasks;\n\n    uint256 public canBeAppliedNum;\n\n    LinkTokenInterface private linkToken;\n\n    IRouterClient private router;\n\n    AggregatorV3Interface private priceFeed;\n\n    mapping(uint256 => applierInfomation) private taskToAccount;\n    mapping(uint256 => chainContractAndSelector)\n        private chainToContractAndSelector;\n\n    constructor(address _router, address _link, address _priceFeed) {\n        owner = msg.sender;\n        router = IRouterClient(_router);\n        linkToken = LinkTokenInterface(_link);\n        priceFeed = AggregatorV3Interface(_priceFeed);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner can call this function.\");\n        _;\n    }\n\n    receive() external payable {}\n\n    function addDestinationContractAndSelector(\n        uint256 chainId,\n        address contractAddress,\n        uint64 selector\n    ) public onlyOwner {\n        chainToContractAndSelector[chainId] = chainContractAndSelector(\n            contractAddress,\n            selector\n        );\n    }\n\n    function hasContractAddressOfChain(\n        uint256 chainId\n    ) public view returns (bool) {\n        return\n            chainToContractAndSelector[chainId].contractAddress != address(0);\n    }\n\n    function hasSelectorOfChain(\n        uint256 chainId\n    ) public view onlyOwner returns (bool) {\n        return chainToContractAndSelector[chainId].selector > 0;\n    }\n\n    function addTask(task memory _task) public onlyOwner {\n        if (!isTaskValid(_task)) {\n            revert TaskInvalid();\n        }\n        if (existTask(_task.name)) {\n            revert TaskAlreadyExists(_task.name);\n        }\n        tasks.push(_task);\n        canBeAppliedNum++;\n    }\n\n    function isTaskValid(task memory _task) internal view returns (bool) {\n        return\n            bytes(_task.name).length > 0 &&\n            bytes(_task.description).length > 0 &&\n            _task.deadline > uint256(block.timestamp) * 1000 &&\n            _task.reward > 0 &&\n            _task.status == Status.Created;\n    }\n\n    function existTask(string memory name) internal view returns (bool) {\n        for (uint256 i = 0; i < tasks.length; i++) {\n            if (\n                keccak256(abi.encodePacked(tasks[i].name)) ==\n                keccak256(abi.encodePacked(name))\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function numOfTasks() public view returns (uint256) {\n        return tasks.length;\n    }\n\n    function showTasks() public view returns (task[] memory, uint256[] memory) {\n        task[] memory showAbleTasks = new task[](canBeAppliedNum);\n        uint256[] memory indexs = new uint256[](canBeAppliedNum);\n        uint256 index = 0;\n        for (uint256 i = 0; i < tasks.length; i++) {\n            if (tasks[i].status == Status.Created) {\n                showAbleTasks[index] = tasks[i];\n                indexs[index] = i;\n                index++;\n            }\n        }\n        return (showAbleTasks, indexs);\n    }\n\n    function applyTask(uint256 chainId, uint256 index) public {\n        taskShouldBeExist(index);\n        if (tasks[index].status != Status.Created) {\n            revert TaskHasBeenApplied(index);\n        }\n        tasks[index].status = Status.Executing;\n        canBeAppliedNum--;\n        taskToAccount[index] = applierInfomation(msg.sender, chainId);\n        emit TaskApplied(index, msg.sender);\n    }\n\n    function taskShouldBeExist(uint256 index) internal view {\n        if (index >= tasks.length) {\n            revert TaskNotExist(index);\n        }\n    }\n\n    // todo mapping 不需要初始化？\n\n    function markDone(uint256 index) public payable onlyOwner {\n        taskShouldBeExist(index);\n        require(\n            tasks[index].status != Status.Created &&\n                tasks[index].status != Status.Finished,\n            \"task doesn't execute\"\n        );\n        applierInfomation memory applier = taskToAccount[index];\n        if (applier.chainId == block.chainid) {\n            sendRewardOnLocalChain(applier.account, index);\n        } else {\n            sendRewardByCCIP(applier.chainId, index);\n        }\n    }\n\n    function sendRewardOnLocalChain(address account, uint256 index) internal {\n        uint256 amount = tasks[index].reward * 1e18;\n        require(\n            address(this).balance.getConversionRate(priceFeed) >= amount,\n            \"need more balance\"\n        );\n        (bool success, ) = address(account).call{\n            value: amount.getTokenAmountByUSD(priceFeed)\n        }(\"\");\n        if (success) {\n            emit TransferSuccess(account, msg.value);\n            cleanTask(index);\n        }\n    }\n\n    function sendRewardByCCIP(uint256 chainId, uint256 index) internal {\n        Client.EVM2AnyMessage memory message = buildCCIPMsg(chainId, index);\n        balanceShouldMoreThanFee(chainId, message);\n        bytes32 messageId = router.ccipSend(\n            chainToContractAndSelector[chainId].selector,\n            message\n        );\n        emit MessageSent(messageId);\n        cleanTask(index);\n    }\n\n    function buildCCIPMsg(\n        uint256 chainId,\n        uint256 taskIndex\n    ) internal view returns (Client.EVM2AnyMessage memory) {\n        return\n            Client.EVM2AnyMessage({\n                receiver: abi.encode(\n                    chainToContractAndSelector[chainId].contractAddress\n                ),\n                data: abi.encode(msg.sender, tasks[taskIndex].reward * 1e18),\n                tokenAmounts: new Client.EVMTokenAmount[](0),\n                extraArgs: Client._argsToBytes(\n                    Client.EVMExtraArgsV1({gasLimit: 980_000})\n                ),\n                feeToken: address(linkToken)\n            });\n    }\n\n    function balanceShouldMoreThanFee(\n        uint256 chainId,\n        Client.EVM2AnyMessage memory message\n    ) internal view {\n        uint256 fees = router.getFee(\n            chainToContractAndSelector[chainId].selector,\n            message\n        );\n        if (fees > linkToken.balanceOf(address(this)))\n            revert NotEnoughBalance(linkToken.balanceOf(address(this)), fees);\n    }\n\n    function cleanTask(uint256 taskIndex) internal {\n        tasks[taskIndex].status = Status.Finished;\n        delete taskToAccount[taskIndex];\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}